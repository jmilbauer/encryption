import copy, hashlib, random
#Rijndael lookup tables courtesy of Wikipedia
#Future implementations of the program should include dynamic generation of Rijndael key ciphers
#useful paper here: https://www.math.washington.edu/~morrow/336_12/papers/juan.pdf

#16x16 = 256-bit Rijndael s-box
sbox = [0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]

#the inverse x box will invert the output of sbox - that is, invsbox(sbox(23))=23
invbox = [0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D]


#https://en.wikipedia.org/wiki/Rijndael_key_schedule
#rcon table from here
rcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d]

#state is generated, expanded key generated, roundnum/roundkey generated for each round, iterate for 14 rounds (this is AES 256), and then for the final round don't do mixcolumns, and then return the final state matrix

#PASSWORD/KEYWORD HANDLING
#AES normally doesn't need a password - rather, information is converted and unconverted using bytes
#AES-256 uses 32-bit keys, which doesn't carry over well into human memory
#To address this, we're going to use a hash function:
def genhash(password):
    bytepassword = str.encode(password)
    #encodes to bytes
    return hashlib.sha256(bytepassword).hexdigest()
    #hexdigest spits out the text of the hash

#note that all this does is shift the list of stuff we pass it over
#shift(asdfjkl,3) would produce 'fjklasd'
#we can apply this to an array of bytes
#this is the rowshift function
#we pass this into the shiftrows step
def shift(row,n):
    return row[n:]+row[0:n]

#ShiftRows step

def shiftRows(state):
    for i in range(4): #4x4 matrix
        state[i*4:i*4+4] = shift(state[i*4:i*4+4],i)
        #we shift by 0, 1, 2, and 3 for the corresponding four columns of the state
        #note that this is one of those functions that's made more inconvenient by our usage of a linear list
        #wikipedia has good diagrams for most of this stuff

def invShiftRows(state):
    for i in range(4):
        state[i*4:i*4+4] = shift(state[i*4:i*4+4],-i)

#handling/initializing the state matrix
#state is normally represented as a 4x4 matrix - for our intents and purposes, a list representation is fine

def initRoundKey (state, roundKey):
    for s in range(len(state)):
        state[s] = state[s]^roundKey[s]

#subByte handles s-box substitution
def subByte(state):
    for i in range(len(state)):
        state[i] = sbox[state[i]]

def invSubByte(state):
    for i in range(len(state)):
        state[i] = invsbox[state[i]]

#keyexpansions/keyscheduler
#this takes in an rcon iteration value i, which is from the lookup table
def keyScheduleCore(word, i):
    word = shift(word,1)
    outword = []
    for x in word:
        outword.append(sbox[byte])
    outword[0]=outword[0]^rcon[i]
    return outword

#https://en.wikipedia.org/wiki/Rijndael_key_schedule - method here
#per the above specification, we're going to be generating a 240-bit code
def expandKey(key):
    expanded = []
    rcon = 1
    #rcon iteration value set to 1
    t = [0,0,0,0]
    #initialization of 4-byte temp variable
    #first 32 bits are the code
    for b in key:
        expanded.append(b)
    while len(expanded)<240:
        #every iteration of this loop generates 32 bits that we append
        for i in range(4):
            t[i] = expanded[(len(expanded)-4)+i]
        #perform the key schedule core on t with rcon iteration value
        t = keyScheduleCore(t, rcon)
        rcon+=1
        expanded.append((expanded[len(expanded)- 32]) ^ (t[i]))
        for i in range(3):
            t[i] = expanded[(len(expanded)-4)+i]
            expanded.append((expanded[len(expanded)- 32]) ^ (t[i]))
        #we do a substitution box
        t[i] = expanded[(len(expanded)-4)+i]
        for j in range(4):
            t[i] = sbox[t[i]]
        expanded.append((expanded[len(expanded)- 32]) ^ (t[i]))
        for i in range(3):
            t[i] = expanded[(len(expanded)-4)+i]
            expanded.append((expanded[len(expanded)- 32]) ^ (t[i]))
    print("Final length of expanded key: {}".format(len(expanded)))
    return expanded

def genRoundKey(expandKey,n):
    return expandKey[(n*16):(n*16+16)]

#http://www.cs.utsa.edu/~wagner/laws/AESkeys.html
#we're going to be using a 32-byte cipher (in correspondence with 256-bit encryption)

#see the finite field arithmetic on wikipedia for implementation in C
def galois(a,b):
    p=0
    bitset=0
    for i in range(8):
        if b & 1 == 1:
            p^=a
        bitset = a & 0x80
        a <<= 1
        #removing the high bit
        if(bitset==0x80):
            a^=0x1B
        b >>= 1
    return p%256

#mixCol
#Wikipedia has explanations in the mix columns & finite-field articles
#also here: http://www.angelfire.com/biz7/atleast/mix_columns.pdf
#https://www.math.washington.edu/~morrow/336_12/papers/juan.pdf

#pseudocode from wikipedia's mixcolumns article
#implementation of mixcolumns using galois
#note that these correspond to the respectedly shifted nature of each of the columns in the state matrix
def mixaCol(col):
    temp = col
    col[0] = galois(temp[0],2) ^ galois(temp[3],1) ^ galois(temp[2],1) ^ galois(temp[1],3)
    col[1] = galois(temp[1],2) ^ galois(temp[0],1) ^ galois(temp[3],1) ^ galois(temp[2],3)
    col[2] = galois(temp[2],2) ^ galois(temp[1],1) ^ galois(temp[0],1) ^ galois(temp[3],3)
    col[3] = galois(temp[3],2) ^ galois(temp[2],1) ^ galois(temp[1],1) ^ galois(temp[0],3)

#values for mixacol and invmixacol from wikipedia matrices
def invmixaCol(col):
    temp = col
    col[0] = galois(temp[0],14) ^ galois(temp[3],9) ^ galois(temp[2],13) ^ galois(temp[1],11)
    col[1] = galois(temp[1],14) ^ galois(temp[0],9) ^ galois(temp[3],13) ^ galois(temp[2],11)
    col[2] = galois(temp[2],14) ^ galois(temp[1],9) ^ galois(temp[0],13) ^ galois(temp[3],11)
    col[3] = galois(temp[3],14) ^ galois(temp[2],9) ^ galois(temp[1],13) ^ galois(temp[0],11)

#we need to generate a temporary col variable and have it iterate through
def mixCol(state):
    for i in range(4):
        col = []
        for j in range(4):
            col.append(state[j*4+i])
        mixaCol(col)
        for j in range(4):
            state[j*+i]=col[j]

def invmixCol(state):
    for i in range(4):
        col=[]
        for j in range(4):
            col.append(state[j*4+i])
        invmixaCol(col)
        for j in range(4):
            state[j*4+i]=col[j]

#--MAIN FUNCTIONS--#
def round(state,roundKey):
    subByte(state)
    shiftRows(state)
    mixCol(state)
    genRoundKey(state)

def invround(state,roundKey):
    genRoundKey(state)
    invMixCol(state)
    invShiftRows(state)
    invSubByte(state)

def mainenc(state,ekey):
    rkey = initRoundKey(ekey,0)
    initRoundKey(state,rkey)
    for i in range(1,14):
        rkey = genRoundKey(ekey, i)
        aesRound(state,rkey)
    rkey = genRoundKey(ekey,14)
    subBytes(state)
    shiftRows(state)
    initRoundKey(state,rkey)
    return state

def maindec(state,ekey):
    rkey = genRoundKey(ekey,14)
    initRoundKey(state,rkey)
    invshift = invShiftRows(state)
    invSubByte(state)
    for i in range(13,0,-1):
        rkey = genRoundKey(ekey,i)
        invround(state,rkey)
    rkey = initRoundKey(ekey,0)
    initRoundKey(state,rkey)
